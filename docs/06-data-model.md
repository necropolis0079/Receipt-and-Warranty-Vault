# 06 - Data Model

> Receipt & Warranty Vault -- Comprehensive Data Model Specification
>
> Status: Finalized | Last Updated: 2026-02-08

---

## Table of Contents

1. [DynamoDB Schema (Single Table Design)](#1-dynamodb-schema-single-table-design)
2. [Global Secondary Index (GSI) Definitions](#2-global-secondary-index-gsi-definitions)
3. [Local Database Schema (Drift / SQLite)](#3-local-database-schema-drift--sqlite)
4. [Conflict Resolution Model](#4-conflict-resolution-model)
5. [Data Lifecycle](#5-data-lifecycle)

---

## 1. DynamoDB Schema (Single Table Design)

### 1.1 Table Configuration

| Property | Value |
|----------|-------|
| Table name | `ReceiptVault` |
| Partition key (PK) | `PK` (String) |
| Sort key (SK) | `SK` (String) |
| Capacity mode | On-demand (pay-per-request) |
| Encryption | AWS-owned key (default DynamoDB encryption at rest) |
| Region | eu-west-1 |
| Point-in-time recovery | Enabled |
| TTL attribute | `ttl` |

### 1.2 Key Design

The single-table design uses prefixed composite keys to distinguish entity types within the same table.

```
+-------------------------------------------+
|  Entity: Receipt                          |
|  PK = USER#<userId>                       |
|  SK = RECEIPT#<receiptId>                 |
+-------------------------------------------+

+-------------------------------------------+
|  Entity: Category Metadata                |
|  PK = USER#<userId>                       |
|  SK = META#CATEGORIES                     |
+-------------------------------------------+
```

**PK format:** `USER#` followed by the Cognito `sub` claim (a UUID assigned by Cognito at user creation). The `USER#` prefix reserves namespace for future entity types (e.g., `HOUSEHOLD#` in v2).

**SK format for receipts:** `RECEIPT#` followed by a UUID v4 generated by the client at receipt creation time. Client-generated IDs enable offline creation without server coordination.

**SK format for category metadata:** The literal string `META#CATEGORIES`. There is exactly one category metadata item per user.

### 1.3 Receipt Entity -- Full Attribute List

| Attribute | DynamoDB Type | Format / Constraints | Description |
|-----------|---------------|---------------------|-------------|
| `PK` | String (S) | `USER#<userId>` | Partition key. Cognito sub prefixed with `USER#`. |
| `SK` | String (S) | `RECEIPT#<receiptId>` | Sort key. Client-generated UUID v4 prefixed with `RECEIPT#`. |
| `receiptId` | String (S) | UUID v4 | Unique identifier for the receipt. Client-generated to support offline creation. Duplicated from SK without the prefix for convenience in application code and GSI projections. |
| `userId` | String (S) | Cognito `sub` (UUID) | The user who owns this receipt. Duplicated from PK without the prefix for the same reason. |
| `storeName` | String (S) | Free text, max 200 chars | The display name of the store/merchant. This is the user-facing value. Initially populated by on-device OCR, refined by LLM, and may be manually edited by the user. If the user edits this field, `storeName` reflects their edit and `userEditedFields` includes `"storeName"`. |
| `extractedMerchantName` | String (S) | Free text, max 200 chars | The raw merchant name as extracted by the Bedrock LLM from the OCR text. This value is never modified by the user -- it is the LLM's best extraction. It serves as an audit trail and as the source of truth for the LLM's interpretation. |
| `purchaseDate` | String (S) | ISO 8601 date (`YYYY-MM-DD`) | The date of purchase. User-confirmed or LLM-extracted. Used for sorting, filtering, and warranty expiry calculation. |
| `extractedDate` | String (S) | ISO 8601 date (`YYYY-MM-DD`) | The raw purchase date as extracted by the Bedrock LLM. Preserved separately so the user's confirmed date and the LLM's extraction can be compared. |
| `totalAmount` | Number (N) | Decimal, precision to 2 decimal places | The total purchase amount. User-confirmed or LLM-extracted. Stored as a number for aggregation queries (monthly spend, category totals). |
| `extractedTotal` | Number (N) | Decimal, precision to 2 decimal places | The raw total amount as extracted by the Bedrock LLM. Preserved separately for the same audit/comparison purpose as `extractedDate`. |
| `currency` | String (S) | ISO 4217 code (e.g., `EUR`, `USD`, `GBP`) | The currency of the transaction. Defaults to the user's preferred currency (from settings). Can be overridden per receipt by the user or auto-detected by the LLM. |
| `category` | String (S) | Free text, max 100 chars | The category assigned to this receipt (e.g., "Electronics", "Groceries", "Clothing"). Can be one of the 10 defaults, a user-created category, or auto-suggested by the LLM. |
| `warrantyMonths` | Number (N) | Integer, 0 = no warranty | The warranty duration in months. `0` means no warranty is associated with this receipt. The user enters this manually or the LLM extracts it from warranty information on the receipt. |
| `warrantyExpiryDate` | String (S) | ISO 8601 date (`YYYY-MM-DD`) | Calculated field: `purchaseDate + warrantyMonths`. Recalculated whenever `purchaseDate` or `warrantyMonths` changes. Used by GSI-4 for warranty expiry queries. Null/absent if `warrantyMonths` is 0. |
| `status` | String (S) | Enum: `active`, `returned`, `deleted` | The lifecycle status of the receipt. `active` = normal receipt. `returned` = user marked the item as returned (receipt is preserved for records but excluded from active warranty tracking). `deleted` = soft-deleted, awaiting TTL cleanup. |
| `imageKeys` | List (L) of Strings | S3 object keys | Ordered list of S3 keys for the original receipt images. A single receipt can have multiple images (e.g., front and back, multi-page receipt). Example: `["originals/abc123/rec456/0.jpg", "originals/abc123/rec456/1.jpg"]`. |
| `thumbnailKeys` | List (L) of Strings | S3 object keys | Ordered list of S3 keys for the thumbnail versions of the receipt images. Same order as `imageKeys`. Example: `["thumbnails/abc123/rec456/0_thumb.jpg"]`. |
| `ocrRawText` | String (S) | Free text, max 10,000 chars | The raw, unstructured text output from the on-device OCR engines (ML Kit + Tesseract merged output). Preserved for full-text search (FTS5 on the client side) and as input to the Bedrock LLM refinement. |
| `llmConfidence` | Number (N) | Integer, 0-100 | The confidence score returned by the Bedrock LLM for its extraction. 0 = no LLM processing has occurred. 1-59 = low confidence (manual review recommended). 60-89 = medium confidence. 90-100 = high confidence. |
| `userNotes` | String (S) | Free text, max 2,000 chars | Free-form notes added by the user. Searchable via FTS5 on the client. Examples: "Birthday gift for Maria", "Exchanged size, kept receipt". |
| `userTags` | List (L) of Strings | Free text tags, max 20 tags | User-defined tags for custom organization. Examples: `["gift", "tax-deductible", "work-expense"]`. Searchable via FTS5 on the client. |
| `isFavorite` | Boolean (BOOL) | `true` or `false` | Whether the user has marked this receipt as a favorite for quick access. Defaults to `false`. |
| `userEditedFields` | List (L) of Strings | Field name strings | Tracks which fields the user has manually edited. Used by the conflict resolution engine to determine whether the client's version or the server/LLM's version takes precedence for Tier 3 fields. Example: `["storeName", "category", "warrantyMonths"]`. |
| `createdAt` | String (S) | ISO 8601 datetime (`YYYY-MM-DDTHH:MM:SSZ`) | Timestamp of receipt creation. Set once at creation time, never modified. |
| `updatedAt` | String (S) | ISO 8601 datetime (`YYYY-MM-DDTHH:MM:SSZ`) | Timestamp of last modification. Updated on every write (client or server). Used by GSI-6 for delta sync queries. |
| `version` | Number (N) | Integer, starts at 1 | Incrementing version counter. Incremented on every write. Used for optimistic concurrency control and conflict detection during sync. |
| `deletedAt` | String (S) | ISO 8601 datetime, or null | Timestamp when the receipt was soft-deleted. Null if the receipt is active or returned. Set when `status` transitions to `deleted`. |
| `ttl` | Number (N) | Unix epoch seconds | DynamoDB TTL attribute. Set to `deletedAt + 30 days` (in epoch seconds) when a receipt is soft-deleted. DynamoDB automatically deletes the item after this timestamp. Null/absent for active and returned receipts. |

**Note on `syncStatus`:** The field `syncStatus` (values: `synced`, `pending`, `conflict`) exists only in the local Drift database on the client. It is never written to DynamoDB. It tracks whether the local copy has been successfully synchronized with the server. See Section 3 for the local schema.

### 1.4 Category Metadata Entity

| Attribute | DynamoDB Type | Format / Constraints | Description |
|-----------|---------------|---------------------|-------------|
| `PK` | String (S) | `USER#<userId>` | Partition key. Same as receipt entities. |
| `SK` | String (S) | `META#CATEGORIES` | Sort key. Literal string identifying this as the category metadata item. |
| `userId` | String (S) | Cognito `sub` (UUID) | The user who owns these categories. |
| `categories` | List (L) of Maps | See structure below | The user's full category list, including defaults and custom categories. |
| `updatedAt` | String (S) | ISO 8601 datetime | Last time the category list was modified. |
| `version` | Number (N) | Integer, starts at 1 | Version counter for conflict resolution during sync. |

**Category item structure (each element in the `categories` list):**

| Field | Type | Description |
|-------|------|-------------|
| `name` | String | Category display name (e.g., "Electronics", "Groceries"). |
| `icon` | String | Icon identifier (e.g., `"electronics"`, `"cart"`). Maps to an icon in the Flutter app. |
| `isDefault` | Boolean | `true` for the 10 built-in default categories, `false` for user-created. Default categories cannot be deleted, only hidden. |
| `isHidden` | Boolean | `true` if the user has hidden this category from the picker. The category still exists for receipts already assigned to it. |
| `sortOrder` | Number | Integer used to order categories in the picker UI. |

**Default categories (10):**
1. Electronics
2. Groceries
3. Clothing & Apparel
4. Home & Furniture
5. Health & Pharmacy
6. Restaurants & Food
7. Transportation
8. Entertainment
9. Services & Subscriptions
10. Other

### 1.5 Example Items

**Receipt item:**
```
{
  "PK":                    "USER#a1b2c3d4-e5f6-7890-abcd-ef1234567890",
  "SK":                    "RECEIPT#f47ac10b-58cc-4372-a567-0e02b2c3d479",
  "receiptId":             "f47ac10b-58cc-4372-a567-0e02b2c3d479",
  "userId":                "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
  "storeName":             "Public (Kotsovolos)",
  "extractedMerchantName": "PUBLIC KOTSOVOLOS SA",
  "purchaseDate":          "2026-01-15",
  "extractedDate":         "2026-01-15",
  "totalAmount":           349.99,
  "extractedTotal":        349.99,
  "currency":              "EUR",
  "category":              "Electronics",
  "warrantyMonths":        24,
  "warrantyExpiryDate":    "2028-01-15",
  "status":                "active",
  "imageKeys":             ["originals/a1b2c3d4/f47ac10b/0.jpg"],
  "thumbnailKeys":         ["thumbnails/a1b2c3d4/f47ac10b/0_thumb.jpg"],
  "ocrRawText":            "PUBLIC KOTSOVOLOS SA\nStore 142 Athens\n15/01/2026\nSamsung Galaxy Buds3 Pro\n1 x 349.99\nTotal EUR 349.99\nWarranty: 24 months\nThank you for your purchase",
  "llmConfidence":         92,
  "userNotes":             "Birthday gift for myself",
  "userTags":              ["electronics", "gift"],
  "isFavorite":            true,
  "userEditedFields":      ["storeName"],
  "createdAt":             "2026-01-15T14:32:00Z",
  "updatedAt":             "2026-01-15T15:01:22Z",
  "version":               3,
  "deletedAt":             null,
  "ttl":                   null
}
```

**Category metadata item:**
```
{
  "PK":         "USER#a1b2c3d4-e5f6-7890-abcd-ef1234567890",
  "SK":         "META#CATEGORIES",
  "userId":     "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
  "categories": [
    { "name": "Electronics",              "icon": "electronics",    "isDefault": true,  "isHidden": false, "sortOrder": 1 },
    { "name": "Groceries",                "icon": "cart",           "isDefault": true,  "isHidden": false, "sortOrder": 2 },
    { "name": "Clothing & Apparel",       "icon": "clothing",      "isDefault": true,  "isHidden": false, "sortOrder": 3 },
    { "name": "Home & Furniture",         "icon": "home",          "isDefault": true,  "isHidden": false, "sortOrder": 4 },
    { "name": "Health & Pharmacy",        "icon": "health",        "isDefault": true,  "isHidden": false, "sortOrder": 5 },
    { "name": "Restaurants & Food",       "icon": "restaurant",    "isDefault": true,  "isHidden": false, "sortOrder": 6 },
    { "name": "Transportation",           "icon": "car",           "isDefault": true,  "isHidden": false, "sortOrder": 7 },
    { "name": "Entertainment",            "icon": "entertainment", "isDefault": true,  "isHidden": false, "sortOrder": 8 },
    { "name": "Services & Subscriptions", "icon": "subscription",  "isDefault": true,  "isHidden": false, "sortOrder": 9 },
    { "name": "Other",                    "icon": "other",         "isDefault": true,  "isHidden": false, "sortOrder": 10 },
    { "name": "Pet Supplies",             "icon": "pet",           "isDefault": false, "isHidden": false, "sortOrder": 11 }
  ],
  "updatedAt":  "2026-01-20T10:15:00Z",
  "version":    2
}
```

---

## 2. Global Secondary Index (GSI) Definitions

All six GSIs are configured with on-demand capacity (inherited from the base table). Each GSI is described with its key schema, projection type, purpose, example query, and design rationale.

### GSI-1: ByUserDate

| Property | Value |
|----------|-------|
| Index name | `ByUserDate` |
| Partition key (PK) | `userId` (String) |
| Sort key (SK) | `purchaseDate` (String, ISO 8601) |
| Projection | ALL (all attributes) |
| Purpose | Browse receipts chronologically. Supports date range queries (e.g., "all receipts from January 2026") and the default home screen sort order (newest first). |

**Example queries:**
- All receipts for a user, newest first: `PK = "a1b2c3d4-...", SK sorted descending`
- Receipts in a date range: `PK = "a1b2c3d4-...", SK BETWEEN "2026-01-01" AND "2026-01-31"`
- Most recent N receipts: `PK = "a1b2c3d4-...", SK sorted descending, Limit = N`

**Design notes:** This is the most frequently used index (every home screen load). ALL projection ensures no additional GetItem calls are needed to render receipt list items.

---

### GSI-2: ByUserCategory

| Property | Value |
|----------|-------|
| Index name | `ByUserCategory` |
| Partition key (PK) | `userId` (String) |
| Sort key (SK) | `category_purchaseDate` (String, composite: `CAT#<category>#<purchaseDate>`) |
| Projection | ALL (all attributes) |
| Purpose | Filter receipts by category. The composite sort key includes purchaseDate so results within a category are automatically sorted chronologically. |

**Sort key format:** `CAT#Electronics#2026-01-15`

This composite format allows:
- All receipts in a category: `PK = "userId", SK begins_with "CAT#Electronics"`
- All receipts in a category within a date range: `PK = "userId", SK BETWEEN "CAT#Electronics#2026-01-01" AND "CAT#Electronics#2026-01-31"`

**Example queries:**
- All "Electronics" receipts: `PK = "a1b2c3d4-...", SK begins_with "CAT#Electronics#"`
- All "Groceries" receipts in 2026: `PK = "a1b2c3d4-...", SK BETWEEN "CAT#Groceries#2026-01-01" AND "CAT#Groceries#2026-12-31"`

---

### GSI-3: ByUserStore

| Property | Value |
|----------|-------|
| Index name | `ByUserStore` |
| Partition key (PK) | `userId` (String) |
| Sort key (SK) | `store_purchaseDate` (String, composite: `STORE#<storeName>#<purchaseDate>`) |
| Projection | ALL (all attributes) |
| Purpose | Filter receipts by store/merchant. Shows all purchases from a specific store, sorted by date. Useful for return lookups ("show me everything I bought at IKEA"). |

**Sort key format:** `STORE#IKEA#2026-01-15`

**Example queries:**
- All receipts from "IKEA": `PK = "a1b2c3d4-...", SK begins_with "STORE#IKEA#"`
- List of unique stores: Client-side aggregation from cached data or a separate scan with projection on `storeName` only.

---

### GSI-4: ByWarrantyExpiry

| Property | Value |
|----------|-------|
| Index name | `ByWarrantyExpiry` |
| Partition key (PK) | `userId_activeWarranty` (String, composite: `<userId>#ACTIVE`) |
| Sort key (SK) | `warrantyExpiryDate` (String, ISO 8601) |
| Projection | ALL (all attributes) |
| Purpose | Query active warranties sorted by expiry date. This is a **sparse index** -- only items where `warrantyMonths > 0` and `status = "active"` have the `userId_activeWarranty` attribute populated. Returned and deleted items, or items with no warranty, are excluded from this index automatically. |

**Sparse index behavior:** The `userId_activeWarranty` attribute is only written to an item when:
- `warrantyMonths > 0` (the receipt has a warranty), AND
- `status = "active"` (the receipt is not returned or deleted).

When a receipt is returned or deleted, or when `warrantyMonths` is set to 0, the `userId_activeWarranty` attribute is removed from the item, which automatically removes it from this GSI. This keeps the index small and focused.

**Example queries:**
- All active warranties, soonest expiry first: `PK = "a1b2c3d4-...#ACTIVE", SK sorted ascending`
- Warranties expiring in the next 30 days: `PK = "a1b2c3d4-...#ACTIVE", SK BETWEEN "2026-02-08" AND "2026-03-10"`
- Warranties expiring today: `PK = "a1b2c3d4-...#ACTIVE", SK = "2026-02-08"`

**Used by:** The daily warranty-check Lambda (EventBridge-triggered) queries this index for each user to find warranties expiring within 30 days and send reminder notifications.

---

### GSI-5: ByUserStatus

| Property | Value |
|----------|-------|
| Index name | `ByUserStatus` |
| Partition key (PK) | `userId` (String) |
| Sort key (SK) | `status_purchaseDate` (String, composite: `STATUS#<status>#<purchaseDate>`) |
| Projection | ALL (all attributes) |
| Purpose | Filter receipts by status (active, returned, deleted). The default view shows only active receipts. The "Returned" filter shows returned items. The "Recently Deleted" view shows soft-deleted items (within the 30-day recovery window). |

**Sort key format:** `STATUS#active#2026-01-15`

**Example queries:**
- All active receipts: `PK = "a1b2c3d4-...", SK begins_with "STATUS#active#"`
- All returned receipts: `PK = "a1b2c3d4-...", SK begins_with "STATUS#returned#"`
- All soft-deleted receipts (recoverable): `PK = "a1b2c3d4-...", SK begins_with "STATUS#deleted#"`

---

### GSI-6: ByUpdatedAt

| Property | Value |
|----------|-------|
| Index name | `ByUpdatedAt` |
| Partition key (PK) | `userId` (String) |
| Sort key (SK) | `updatedAt` (String, ISO 8601 datetime) |
| Projection | KEYS_ONLY (PK, SK, and the base table keys only) |
| Purpose | Delta sync queries. The client sends its last sync timestamp; the server queries this index to find all items updated since that timestamp. Only keys are projected because the client then fetches full items individually (or in a BatchGetItem call) -- this minimizes the storage cost of the GSI. |

**Example queries:**
- Items updated since last sync: `PK = "a1b2c3d4-...", SK > "2026-02-07T12:00:00Z"`
- All items updated today: `PK = "a1b2c3d4-...", SK begins_with "2026-02-08"`

**KEYS_ONLY rationale:** This index is queried only during sync operations, not for UI rendering. The sync process needs to know *which* items have changed, then fetches their full attributes via BatchGetItem on the base table. KEYS_ONLY projection reduces the GSI's storage footprint by approximately 90% compared to ALL projection, since receipt items can be large (due to `ocrRawText`).

---

### GSI Summary Table

```
+-------+------------------+-----------------------------+-----------------------+------------------+
| GSI   | Name             | PK                          | SK                    | Projection       |
+-------+------------------+-----------------------------+-----------------------+------------------+
| GSI-1 | ByUserDate       | userId                      | purchaseDate          | ALL              |
| GSI-2 | ByUserCategory   | userId                      | CAT#category#date     | ALL              |
| GSI-3 | ByUserStore      | userId                      | STORE#storeName#date  | ALL              |
| GSI-4 | ByWarrantyExpiry | userId#ACTIVE (sparse)      | warrantyExpiryDate    | ALL              |
| GSI-5 | ByUserStatus     | userId                      | STATUS#status#date    | ALL              |
| GSI-6 | ByUpdatedAt      | userId                      | updatedAt             | KEYS_ONLY        |
+-------+------------------+-----------------------------+-----------------------+------------------+
```

---

## 3. Local Database Schema (Drift / SQLite)

The local database mirrors the DynamoDB schema but includes additional fields for offline state management. It is encrypted with SQLCipher (AES-256). The Drift ORM generates type-safe Dart code for all queries.

### 3.1 `receipts` Table

This table stores the complete receipt data locally. It mirrors all DynamoDB attributes and adds client-only fields for sync tracking and local image management.

| Column | SQLite Type | Nullable | Default | Description |
|--------|-------------|----------|---------|-------------|
| `receipt_id` | TEXT | NOT NULL | -- | Primary key. UUID v4, client-generated. Same value as DynamoDB `receiptId`. |
| `user_id` | TEXT | NOT NULL | -- | Cognito sub. |
| `store_name` | TEXT | YES | NULL | Display store name (user-edited or LLM-extracted). |
| `extracted_merchant_name` | TEXT | YES | NULL | Raw LLM extraction of merchant name. |
| `purchase_date` | TEXT | YES | NULL | ISO 8601 date. |
| `extracted_date` | TEXT | YES | NULL | Raw LLM extraction of date. |
| `total_amount` | REAL | YES | NULL | Total purchase amount. |
| `extracted_total` | REAL | YES | NULL | Raw LLM extraction of total. |
| `currency` | TEXT | NOT NULL | 'EUR' | ISO 4217 currency code. Default from user settings. |
| `category` | TEXT | YES | NULL | Category name. |
| `warranty_months` | INTEGER | NOT NULL | 0 | Warranty duration. 0 = no warranty. |
| `warranty_expiry_date` | TEXT | YES | NULL | Calculated: purchaseDate + warrantyMonths. |
| `status` | TEXT | NOT NULL | 'active' | `active`, `returned`, or `deleted`. |
| `image_keys` | TEXT | YES | NULL | JSON-encoded list of S3 keys. |
| `thumbnail_keys` | TEXT | YES | NULL | JSON-encoded list of S3 thumbnail keys. |
| `ocr_raw_text` | TEXT | YES | NULL | Raw OCR output. Indexed by FTS5 for search. |
| `llm_confidence` | INTEGER | NOT NULL | 0 | LLM confidence score (0-100). |
| `user_notes` | TEXT | YES | NULL | User free-form notes. Indexed by FTS5. |
| `user_tags` | TEXT | YES | NULL | JSON-encoded list of tag strings. Indexed by FTS5. |
| `is_favorite` | INTEGER | NOT NULL | 0 | Boolean (0 = false, 1 = true). |
| `user_edited_fields` | TEXT | YES | NULL | JSON-encoded list of field names. |
| `created_at` | TEXT | NOT NULL | -- | ISO 8601 datetime. Set at creation. |
| `updated_at` | TEXT | NOT NULL | -- | ISO 8601 datetime. Updated on every write. |
| `version` | INTEGER | NOT NULL | 1 | Incrementing version for conflict detection. |
| `deleted_at` | TEXT | YES | NULL | ISO 8601 datetime. Set on soft delete. |
| `sync_status` | TEXT | NOT NULL | 'pending' | **LOCAL ONLY.** `synced`, `pending`, or `conflict`. Not sent to server. |
| `last_synced_at` | TEXT | YES | NULL | **LOCAL ONLY.** ISO 8601 datetime of last successful sync for this receipt. |
| `local_image_paths` | TEXT | YES | NULL | **LOCAL ONLY.** JSON-encoded list of local file paths for cached/captured images. |

**Indexes:**
- Primary key: `receipt_id`
- Index on `user_id` (for user-scoped queries)
- Index on `purchase_date` (for chronological sorting)
- Index on `category` (for category filtering)
- Index on `status` (for status filtering)
- Index on `sync_status` (for sync queue processing -- quickly find all `pending` items)
- Index on `warranty_expiry_date` (for warranty reminders)
- Index on `updated_at` (for delta sync queries)

**FTS5 virtual table:** `receipts_fts`
- Indexed columns: `store_name`, `ocr_raw_text`, `user_notes`, `user_tags`
- Tokenizer: `unicode61` (supports accented characters and Greek text)
- Used for the keyword search feature: the user types a search term, and FTS5 finds matching receipts across all indexed text fields.

### 3.2 `categories` Table

| Column | SQLite Type | Nullable | Default | Description |
|--------|-------------|----------|---------|-------------|
| `id` | INTEGER | NOT NULL | AUTOINCREMENT | Local primary key. |
| `name` | TEXT | NOT NULL | -- | Category display name. Unique per user. |
| `icon` | TEXT | NOT NULL | 'other' | Icon identifier mapping to a Flutter icon. |
| `is_default` | INTEGER | NOT NULL | 0 | Boolean. 1 = one of the 10 built-in defaults. |
| `is_hidden` | INTEGER | NOT NULL | 0 | Boolean. 1 = hidden from the category picker. |
| `sort_order` | INTEGER | NOT NULL | 0 | Display order in the picker. |

**Indexes:**
- Primary key: `id`
- Unique index on `name`
- Index on `sort_order`

### 3.3 `sync_queue` Table

The sync queue holds operations that need to be sent to the server. Items are added when the user creates, updates, or deletes a receipt while offline (or when the immediate sync attempt fails). The background sync service (WorkManager) processes this queue when connectivity is available.

| Column | SQLite Type | Nullable | Default | Description |
|--------|-------------|----------|---------|-------------|
| `id` | INTEGER | NOT NULL | AUTOINCREMENT | Local primary key. |
| `receipt_id` | TEXT | NOT NULL | -- | The receipt this operation applies to. |
| `operation` | TEXT | NOT NULL | -- | `create`, `update`, `delete`, `upload_image`, or `refine_ocr`. |
| `payload` | TEXT | YES | NULL | JSON-encoded operation payload. For `create` and `update`, this contains the full receipt data. For `upload_image`, this contains the local file path. For `delete`, this is null (the receipt_id is sufficient). |
| `created_at` | TEXT | NOT NULL | -- | ISO 8601 datetime when the operation was queued. |
| `retry_count` | INTEGER | NOT NULL | 0 | Number of failed sync attempts. Operations are abandoned after 10 retries and flagged for manual resolution. |
| `last_error` | TEXT | YES | NULL | The error message from the most recent failed attempt. Useful for debugging. |
| `priority` | INTEGER | NOT NULL | 0 | Processing priority. Higher values are processed first. Image uploads have lower priority than data sync to ensure receipt metadata is synced quickly. |

**Indexes:**
- Primary key: `id`
- Index on `receipt_id` (to find pending operations for a specific receipt)
- Index on `created_at` (to process operations in order)
- Index on `retry_count` (to skip or deprioritize frequently-failing operations)

**Processing rules:**
- Operations are processed in order of `priority` (descending), then `created_at` (ascending).
- If an operation fails, `retry_count` is incremented and the operation is retried on the next sync cycle with exponential backoff (delay = 2^retry_count minutes, capped at 60 minutes).
- After 10 failed retries, the operation is marked as "failed" and the corresponding receipt's `sync_status` is set to `conflict`. The user is notified via a subtle badge on the sync status indicator.
- When a newer operation for the same receipt is queued, older `update` operations for that receipt are coalesced (merged into the newest version) to avoid redundant server calls.

### 3.4 `settings` Table

| Column | SQLite Type | Nullable | Default | Description |
|--------|-------------|----------|---------|-------------|
| `key` | TEXT | NOT NULL | -- | Setting identifier. Primary key. |
| `value` | TEXT | YES | NULL | Setting value, stored as a string (parsed by the app). |

**Standard keys:**

| Key | Example Value | Description |
|-----|---------------|-------------|
| `default_currency` | `"EUR"` | Default currency for new receipts. |
| `storage_mode` | `"cloud_and_device"` | `cloud_and_device` or `device_only`. |
| `warranty_reminder_days` | `"[30, 7, 1, 0]"` | JSON array of days-before-expiry for reminders. |
| `sync_on_cellular` | `"false"` | Whether to sync on cellular data. |
| `image_cache_max_mb` | `"500"` | Maximum local image cache size in MB. |
| `theme_mode` | `"system"` | `light`, `dark`, or `system`. |
| `locale` | `"en"` | App language: `en` or `el`. |
| `biometric_lock_enabled` | `"false"` | Whether the app requires biometric/PIN to open. |
| `last_full_sync_at` | `"2026-02-01T08:00:00Z"` | Timestamp of last full reconciliation. |
| `last_delta_sync_at` | `"2026-02-08T12:30:00Z"` | Timestamp of last delta sync. |
| `onboarding_completed` | `"true"` | Whether the user has completed onboarding. |

---

## 4. Conflict Resolution Model

### 4.1 Overview

Conflicts occur when the same receipt is modified on both the client and the server between sync cycles. The conflict resolution model uses a **field-level merge with ownership tiers** strategy, which is more sophisticated than simple "last write wins" but avoids the complexity of full CRDT (Conflict-free Replicated Data Type) implementations.

The key insight is that different fields have different natural "owners":
- LLM-extracted fields are produced by the server and should generally be trusted.
- User-entered fields are produced by the client and should always be preserved.
- Some fields can be overridden by either side, depending on whether the user has manually edited them.

### 4.2 Conflict Resolution Tiers

**Tier 1: Server/LLM Wins**

These fields are produced by server-side LLM processing. The server's version always takes precedence because the LLM may have reprocessed the receipt with improved accuracy.

| Field | Rationale |
|-------|-----------|
| `extractedMerchantName` | Raw LLM output. User never edits this directly. |
| `extractedDate` | Raw LLM output. User never edits this directly. |
| `extractedTotal` | Raw LLM output. User never edits this directly. |
| `ocrRawText` | Raw OCR output. May be updated if the server re-runs OCR. |
| `llmConfidence` | Computed by the LLM. Client has no reason to override. |

**Tier 2: Client/User Wins**

These fields are purely user-generated. The client's version always takes precedence because only the user creates and modifies these values.

| Field | Rationale |
|-------|-----------|
| `userNotes` | Free-form text entered by the user. |
| `userTags` | Tags created by the user. |
| `isFavorite` | User preference toggle. |

**Tier 3: Conditional -- Client Override Precedence**

These fields can be populated by either the LLM or the user. The `userEditedFields` array determines which version wins.

| Field | If field is in `userEditedFields` | If field is NOT in `userEditedFields` |
|-------|-----------------------------------|---------------------------------------|
| `storeName` | Client version wins (user manually corrected the store name). | Server version wins (LLM extraction is likely more accurate than on-device OCR). |
| `category` | Client version wins (user deliberately chose this category). | Server version wins (LLM auto-suggestion may be more appropriate). |
| `warrantyMonths` | Client version wins (user manually entered warranty duration). | Server version wins (LLM may have extracted warranty info from the receipt). |
| `purchaseDate` | Client version wins (user manually corrected the date). | Server version wins (LLM date extraction is usually reliable). |
| `totalAmount` | Client version wins (user manually corrected the amount). | Server version wins (LLM total extraction is usually reliable). |
| `currency` | Client version wins (user explicitly changed the currency). | Server version wins (LLM may have detected a different currency on the receipt). |

### 4.3 Version Number

- Every receipt has a `version` field, starting at 1 and incrementing on every write (client or server).
- The version number is used for **optimistic concurrency control**: when the client sends an update to the server, it includes the version number it is updating from. If the server's current version is higher, a conflict has occurred.
- The server responds with HTTP 409 (Conflict) and includes the server's current version of the receipt. The client then applies the merge algorithm (Section 4.4) to produce a resolved version.

### 4.4 Merge Algorithm (Step-by-Step)

When the client syncs a receipt and the server has a different (higher) version, the following merge algorithm is executed on the client:

```
MERGE ALGORITHM
===============

Input:
  - CLIENT_VERSION: The receipt as it exists on the client (with local changes)
  - SERVER_VERSION: The receipt as it exists on the server (received in 409 response)
  - CLIENT_EDITED: The userEditedFields array from CLIENT_VERSION

Output:
  - MERGED_VERSION: The resolved receipt to be saved locally and pushed to server

Steps:

1. START with a copy of SERVER_VERSION as the base for MERGED_VERSION.

2. For each TIER 1 field (server/LLM wins):
   - Keep the value from SERVER_VERSION.
   - (No action needed -- already in MERGED_VERSION from step 1.)

3. For each TIER 2 field (client/user wins):
   - Overwrite MERGED_VERSION with the value from CLIENT_VERSION.

4. For each TIER 3 field (conditional):
   - IF the field name is in CLIENT_EDITED:
       - Overwrite MERGED_VERSION with the value from CLIENT_VERSION.
       - Ensure the field name remains in MERGED_VERSION.userEditedFields.
   - ELSE:
       - Keep the value from SERVER_VERSION.
       - (No action needed.)

5. Merge the userEditedFields arrays:
   - MERGED_VERSION.userEditedFields = union of CLIENT_EDITED
     and SERVER_VERSION.userEditedFields.
   - (Both sides may have tracked different user edits.)

6. Set MERGED_VERSION.version = SERVER_VERSION.version + 1.

7. Set MERGED_VERSION.updatedAt = current timestamp.

8. Set MERGED_VERSION.syncStatus = "pending" (local only).

9. Save MERGED_VERSION to local Drift database.

10. Push MERGED_VERSION to server via the sync endpoint.
    - If the server accepts (HTTP 200): set syncStatus = "synced".
    - If the server rejects with 409 again: repeat from step 1
      with the new SERVER_VERSION (max 3 merge attempts).
    - If max attempts exceeded: set syncStatus = "conflict"
      and notify the user to review manually.
```

**Edge cases:**

- **Image keys conflict:** If both client and server have added new images, the merged version includes the union of both image lists (images are append-only; users delete images explicitly). Duplicate S3 keys are removed.

- **Status conflict:** If the client has deleted a receipt but the server has updated it (or vice versa), the delete takes precedence. Once a user deletes a receipt, it stays deleted regardless of server-side changes.

- **Category metadata conflict:** The categories list uses a simpler merge: the union of both category lists, with the client's `sortOrder` and `isHidden` values taking precedence for categories that exist on both sides.

### 4.5 Conflict Notification to User

When a conflict cannot be automatically resolved (after 3 merge attempts), the receipt is marked with `syncStatus = "conflict"` and the user sees:
- A small warning icon on the receipt card in the list view.
- A "Sync Conflict" banner at the top of the receipt detail screen.
- Options to "Keep My Version", "Use Server Version", or "Review Differences" (a side-by-side comparison of the two versions).

This manual resolution path is expected to be extremely rare -- the tiered merge algorithm handles the vast majority of conflicts automatically.

---

## 5. Data Lifecycle

### 5.1 Creation

```
1. User captures a receipt (camera, gallery, or file import).

2. Client generates a UUID v4 for receiptId.

3. Client performs on-device OCR (ML Kit + Tesseract).

4. Client saves the receipt to the local Drift database:
   - syncStatus = "pending"
   - version = 1
   - createdAt = now
   - updatedAt = now
   - status = "active"
   - All OCR-extracted fields populated (storeName, purchaseDate, etc.)

5. Client saves the receipt image to the local file system
   (encrypted via SQLCipher-adjacent file encryption).
   Records the local path in local_image_paths.

6. Client adds two entries to the sync_queue:
   a. operation = "create" (receipt metadata)
   b. operation = "upload_image" (image file)

7. If online, the sync service processes the queue immediately:
   a. POST /receipts with receipt data -> server creates DynamoDB item
   b. GET /receipts/{id}/upload-url -> server returns pre-signed URL
   c. PUT to pre-signed URL -> image uploaded to S3
   d. Server thumbnail Lambda triggers on S3 PUT -> thumbnail created
   e. Client updates local record: syncStatus = "synced",
      imageKeys and thumbnailKeys populated from server response

8. If offline, items remain in sync_queue until connectivity
   is restored (WorkManager processes on next sync cycle).
```

### 5.2 Sync (Delta and Full Reconciliation)

**Delta Sync (every 15 minutes or on-resume):**

```
1. Client reads last_delta_sync_at from settings table.

2. Client sends GET /receipts/sync?since={last_delta_sync_at}
   to the server.

3. Server queries GSI-6 (ByUpdatedAt) for all items with
   updatedAt > since. Returns item keys.

4. Server fetches full items via BatchGetItem on the base table.
   Returns list of updated/new receipts.

5. For each receipt returned by the server:
   a. If the receipt does not exist locally: insert it.
   b. If the receipt exists locally with syncStatus = "synced":
      overwrite with server version.
   c. If the receipt exists locally with syncStatus = "pending":
      run the merge algorithm (Section 4.4).

6. Client processes its own sync_queue: pushes all pending
   local changes to the server.

7. Client updates last_delta_sync_at = now.
```

**Full Reconciliation (every 7 days):**

```
1. Client reads last_full_sync_at from settings table.
   If now - last_full_sync_at < 7 days, skip.

2. Client sends GET /receipts/sync?full=true to the server.

3. Server returns ALL receipt IDs and version numbers for the user
   (lightweight response, no full attributes).

4. Client compares server list with local database:
   a. Receipts on server but not locally: fetch and insert.
   b. Receipts locally but not on server (and syncStatus = "synced"):
      these were deleted on the server -- remove locally.
   c. Receipts with version mismatch: fetch full server version
      and run merge algorithm.

5. Client updates last_full_sync_at = now.
```

### 5.3 Soft Delete

```
1. User deletes a receipt (swipe-to-delete or delete button).

2. Client updates the local receipt:
   - status = "deleted"
   - deletedAt = now
   - updatedAt = now
   - version = version + 1
   - syncStatus = "pending"

3. Client does NOT delete the local image files yet
   (they may be needed if the user recovers the receipt).

4. Client adds "update" operation to sync_queue.

5. When synced, server updates the DynamoDB item:
   - status = "deleted"
   - deletedAt = now
   - ttl = deletedAt + 30 days (Unix epoch seconds)
   - The userId_activeWarranty attribute is removed
     (removes from GSI-4 sparse index)

6. S3 images are NOT deleted. S3 Versioning preserves them.
   If the user recovers the receipt within 30 days, the images
   are still accessible.

7. After 30 days:
   - DynamoDB TTL automatically deletes the item.
   - S3 NoncurrentVersionExpiration lifecycle rule cleans up
     any versioned objects associated with the receipt.
   - Client removes the receipt from the local database and
     deletes cached images on the next full reconciliation.
```

**Recovery (within 30 days):**

```
1. User navigates to "Recently Deleted" (filtered view via GSI-5).

2. User taps "Recover" on a deleted receipt.

3. Client updates the local receipt:
   - status = "active"
   - deletedAt = null
   - ttl = null (removed)
   - updatedAt = now
   - version = version + 1
   - If warranty is still valid, userId_activeWarranty is restored.

4. Change is synced to server, which clears TTL and restores
   the item to active status.
```

### 5.4 Hard Delete (Account Deletion)

When a user requests account deletion (GDPR right to erasure), a cascade delete is triggered that removes all user data across all services.

```
1. User requests account deletion from Settings screen.

2. Client confirms the action with a dialog:
   "This will permanently delete your account and ALL receipts.
    This action cannot be undone. Are you sure?"

3. Client calls DELETE /user/delete.

4. Server (user-delete Lambda) executes the cascade:

   a. COGNITO:
      - Delete the Cognito user (AdminDeleteUser).
      - This invalidates all tokens immediately.

   b. DYNAMODB:
      - Query PK = USER#<userId> to get ALL items
        (receipts + category metadata).
      - BatchWriteItem to delete all items (25 items per batch).
      - Repeat until all items are deleted.

   c. S3:
      - List all objects under originals/<userId>/ and
        thumbnails/<userId>/ prefixes.
      - Delete all objects, INCLUDING all versions
        (ListObjectVersions + DeleteObjects for each version).
      - This is the crypto-shredding complement: even if objects
        exist in S3, deleting the KMS key schedule (optional,
        for extreme compliance) would render them unreadable.

   d. SNS:
      - Delete the user's platform endpoint (device token mapping).

5. Lambda returns HTTP 200 (success) or HTTP 500 (partial failure,
   with details of which service failed -- retry mechanism handles).

6. Client clears all local data:
   - Drift database: drop all tables and recreate.
   - File system: delete all cached images.
   - flutter_secure_storage: delete encryption keys and tokens.
   - Navigate to the welcome/sign-in screen.
```

**Failure handling:** If any step in the cascade fails, the Lambda logs the failure to CloudWatch and the item is sent to a Dead Letter Queue for manual retry. The user's account is marked as "deletion in progress" to prevent re-authentication. A daily cleanup Lambda processes the DLQ and retries failed deletions.

### 5.5 Export

Users can export their data at any time (GDPR right to data portability).

```
1. User selects "Export My Data" from Settings, optionally
   with a date range filter.

2. Client calls POST /user/export with optional date range.

3. Server (export-data Lambda):
   a. Queries DynamoDB for all user receipts (or filtered by date).
   b. Generates a JSON file with all receipt metadata.
   c. Generates a CSV file with a flat tabular representation
      (one row per receipt, columns for all fields).
   d. For each receipt, downloads the original images from S3.
   e. Packages everything into a ZIP archive:
      export/
        receipts.json
        receipts.csv
        images/
          <receiptId>/
            0.jpg
            1.jpg
          <receiptId>/
            0.jpg
   f. Uploads the ZIP to a temporary S3 location with a
      pre-signed download URL (1-hour expiry).

4. Server returns the pre-signed download URL.

5. Client downloads the ZIP and presents a share sheet
   (save to files, send via email, etc.).

6. The temporary ZIP is automatically cleaned up by an S3
   lifecycle rule (delete after 24 hours).
```

---

*This document defines the complete data model for Receipt & Warranty Vault. For the technical architecture that operates on this data, see [05 - Technical Architecture](./05-technical-architecture.md). For API endpoints that read and write this data, see [07 - API Design](./07-api-design.md).*
